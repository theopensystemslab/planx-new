import {
  array,
  boolean,
  mixed,
  object,
  SchemaOf,
  string,
  TestContext,
  ValidationError,
} from "yup";

import { FileUploadSlot } from "../FileUpload/model";
import { MoreInformation } from "../shared";
import {
  checkIfConditionalRule,
  Condition,
  FileList,
  FileType,
  FileUploadAndLabel,
  getTagsForSlot,
  Operator,
  Rule,
  UserFile,
} from "./model";

const moreInformationSchema: SchemaOf<MoreInformation> = object({
  howMeasured: string(),
  policyRef: string(),
  info: string(),
  notes: string(),
  definitionImg: string(),
});

const valFnSchema = mixed().when("condition", {
  is: checkIfConditionalRule,
  then: (schema) => schema.required(),
  otherwise: (schema) => schema.equals([undefined]),
});

const operatorSchema = mixed().when("condition", {
  is: checkIfConditionalRule,
  then: (schema) => schema.equals([Operator.Equals]).required(),
  otherwise: (schema) => schema.equals([undefined]),
});

export const ruleSchema: SchemaOf<Rule> = object({
  condition: mixed().oneOf(Object.values(Condition)).required(),
  operator: operatorSchema,
  val: valFnSchema,
  fn: valFnSchema,
});

export const fileTypeSchema: SchemaOf<FileType> = object({
  name: string().required(),
  fn: string().required(),
  rule: ruleSchema,
  moreInformation: moreInformationSchema.optional(),
});

export const fileUploadAndLabelSchema: SchemaOf<FileUploadAndLabel> = object({
  title: string().required(),
  description: string(),
  fn: string(),
  fileTypes: array().of(fileTypeSchema).required().min(1),
  hideDropZone: boolean(),
}).concat(moreInformationSchema);

interface SlotsSchemaTestContext extends TestContext {
  fileList: FileList;
}

export const slotsSchema = array()
  .required()
  .test({
    name: "minFileUploaded",
    message: "Upload at least one file",
    test: (slots, { options: { context } }) => {
      if (!context) throw new Error("Missing context for slotsSchema");
      if (!slots) throw new Error("Missing slots for slotsSchema");

      const { fileList } = context as SlotsSchemaTestContext;
      const noFilesAreRequired = Boolean(!fileList.required.length);
      if (noFilesAreRequired) return true;

      const isAtLeastOneFileUploaded = slots.length > 0;
      return isAtLeastOneFileUploaded;
    },
  })
  .test({
    name: "nonUploading",
    message: "Please wait for upload to complete",
    test: (slots?: Array<FileUploadSlot>) => {
      const isAnyUploadInProgress = Boolean(
        slots?.some((slot) => slot.status === "uploading"),
      );
      return !isAnyUploadInProgress;
    },
  })
  .test({
    name: "errorStatus",
    message: "Remove files which failed to upload",
    test: (slots?: Array<FileUploadSlot>) => {
      const didAnyUploadFail = slots?.some((slot) => slot.status === "error");
      return !didAnyUploadFail;
    },
  });

interface FileListSchemaTestContext extends TestContext {
  slots: FileUploadSlot[];
}

export const fileLabelSchema = object().test({
  name: "allFilesTagged",
  test: (fileList, { options: { context } }) => {
    if (!context) throw new Error("Missing context for fileListSchema");
    const { slots } = context as FileListSchemaTestContext;
    const errors: ValidationError[] = [];
    slots?.forEach((slot) => {
      const tagsForSlot = getTagsForSlot(
        slot.id,
        fileList as unknown as FileList,
      );
      if (!tagsForSlot.length) {
        errors.push(
          new ValidationError(
            `File ${slot.file.path} is not labeled`,
            undefined,
            slot.id,
          ),
        );
      }
    });

    // Valid fileLabelSchema
    if (!errors.length) return true;

    return new ValidationError(errors, undefined, undefined, "allFilesTagged");
  },
});

/**
 * Format errors generated by fileLabelSchema so that we can access them by path (file id) in the UI
 */
export const formatFileLabelSchemaErrors = (
  errors: ValidationError,
): Record<string, string> =>
  Object.fromEntries(errors.inner.map(({ path, message }) => [path, message]));

export const fileListSchema = object({
  required: array().test({
    name: "allRequiredFilesUploaded",
    message: "Please upload and label all required files",
    test: (userFile?: UserFile[]) => {
      const isEverySlotFilled = Boolean(
        userFile?.every(
          (userFile) => userFile?.slots && userFile.slots.length > 0,
        ),
      );
      return isEverySlotFilled;
    },
  }),
});
