import { getValidSchemaValues } from "@opensystemslab/planx-core";
import { ComponentType as TYPES } from "@opensystemslab/planx-core/types";
import { PASSPORT_REQUESTED_FILES_KEY } from "@planx/components/FileUploadAndLabel/model";
import { convertNumberToText } from "@planx/components/List/utils";
import { useStore } from "pages/FlowEditor/lib/store";

import { FileUploadField, ResponseValue, Schema, SchemaUserResponse } from "./model";

interface GetRequestedFilesArgs {
  schemaFn: string;
  schema: Schema;
  userData: SchemaUserResponse[];
  context: TYPES.List | TYPES.Page;
}

/**
 * Generate passport values describing requested files for this service
 * Returns existing data, amended with files requested by this List or Page component
 */
export const getRequestedFiles = ({
  schemaFn,
  schema,
  userData,
  context,
}: GetRequestedFilesArgs) => {
  const fileUploadFields = schema.fields.filter(
    (field): field is FileUploadField => field.type === "fileUpload",
  );

  const responseDataValues = getResponseDataValues({
    fileUploadFields,
    schemaFn,
    userData,
    context,
  });

  // Get current requested files state
  const { required, recommended, optional } = useStore
    .getState()
    .requestedFiles();

  // Return updated requested files state
  return {
    [PASSPORT_REQUESTED_FILES_KEY]: {
      required: [...required, ...responseDataValues.required],
      optional: [...optional, ...responseDataValues.optional],
      recommended,
    },
  };
};

const getResponseDataValues = ({
  fileUploadFields,
  schemaFn,
  userData,
  context,
}: {
  fileUploadFields: FileUploadField[];
  schemaFn: string;
  userData: SchemaUserResponse[];
  context: TYPES.List | TYPES.Page;
}): { required: string[]; optional: string[] } => {
  const result: ReturnType<typeof getResponseDataValues> = {
    required: [],
    optional: [],
  };

  if (context === TYPES.List) {
    fileUploadFields.forEach(({ data, required = true }) => {
      userData.forEach((_, index) => {
        const path = getPath({ context, dataFn: data.fn, schemaFn, index })
        return required
          ? result.required.push(path)
          : result.optional.push(path);
      });
    });
  }

  if (context === TYPES.Page) {
    fileUploadFields.forEach(({ data, required = true }) => {
      const path = getPath({ context, dataFn: data.fn, schemaFn });
      return required ? result.required.push(path) : result.optional.push(path);
    });
  }

  return result;
};

interface PagePathArgs {
  context: TYPES.Page;
  dataFn: string;
  schemaFn: string;
}

interface ListPathArgs {
  context: TYPES.List;
  index: number   
  dataFn: string;
  schemaFn: string;
}

export const getPath = (args: ListPathArgs | PagePathArgs) => {
  const { context, dataFn, schemaFn } = args;

  // Responses using a valid schema "FileType" should be extracted as a root-level passport field
  const fileTypeValues = getValidSchemaValues("FileType") || [];
  const isSchemaFileType = fileTypeValues.includes(dataFn);
  if (isSchemaFileType) return dataFn;

  switch (context) {
    case TYPES.List:
      return `${schemaFn}.${convertNumberToText(args.index + 1)}.${dataFn}`;
    case TYPES.Page:
      return `${schemaFn}.${dataFn}`;
  }
}

/**
 * Responses generated by a FileUploadField, using a valid schema "FileType" should be extracted as a root-level passport field
 */
export const extractSchemaFileTypes = ({ userData, schema }: { userData: SchemaUserResponse[], schema: Schema }) => {
  const fileUploadFns = schema.fields
    .filter(({ type }) => type === "fileUpload")
    .map(({ data }) => data.fn);
  
  const fileTypeValues = getValidSchemaValues("FileType") || [];

  // Find responses for FileUploadFields which use a schema FileType data value
  const entries = userData.flatMap(response =>
    Object.entries(response).filter(([key]) => 
      fileUploadFns.includes(key) && fileTypeValues.includes(key)
    )
  );

  const schemaFileTypes: Map<string, ResponseValue<FileUploadField>> = new Map();

  entries.forEach(([key, value]) => {
    const currentValue = schemaFileTypes.get(key);
    if (!currentValue) {
      schemaFileTypes.set(key, value as ResponseValue<FileUploadField>);
      return;
    }
    
    schemaFileTypes.set(key, currentValue.concat(value as ResponseValue<FileUploadField>));  
  });
  
  const result = Object.fromEntries(schemaFileTypes);
  return result;
};